{"version":3,"mappings":"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","names":["mdCheck","text","headers","bold","italic","code","links","mdLists","numberedLists","lists","tables","tableDelimiters","yamlSeparators","tableScore","isLikelyPlainTextFormatting","featureTypes","htmlCheck","trimmed","isTruncatedSample","actualStart","actualEnd","parts","startsWithTag","endsWithTag","openTags","closeTags","hasHtmlAttrs","count","pattern","jsonCheck","xmlCheck","hasRoot","csvCheck","lines","l","yamlCheck","colonCount","listCount","structuredData","nestedStructure","frontMatterEnd","keyValue","listItems","indented","txtCheck","texCheck","commands","environments","hasDocumentclass","hasDocumentEnv","textFormatChecks","detectFormatFromText","content","filePath","formats","n","checkFormats","sampleSize","sample","head","tail","formatChecks","bestMatch","format","check","thisConfidence","thisReasons","compText"],"ignoreList":[],"sources":["../../../../dist/utils/src/detectFormat/formats/md.js","../../../../dist/utils/src/detectFormat/formats/html.js","../../../../dist/utils/src/detectFormat/formats/json.js","../../../../dist/utils/src/detectFormat/formats/xml.js","../../../../dist/utils/src/detectFormat/formats/csv.js","../../../../dist/utils/src/detectFormat/formats/yaml.js","../../../../dist/utils/src/detectFormat/formats/txt.js","../../../../dist/utils/src/detectFormat/formats/tex.js","../../../../dist/utils/src/detectFormat/index.js"],"sourcesContent":["export const mdCheck = {\n    quickCheck: (text) => /^#{1,6} /gm.test(text) ||\n        /\\*\\*/.test(text) ||\n        /```/.test(text) ||\n        /\\[.*\\]\\(/.test(text) ||\n        /^\\s*[-*+]\\s+[^:]+$/gm.test(text) || // More specific list pattern, exclude lines ending with colons\n        /^---\\s*$|^---\\s*\\n/gm.test(text) || // YAML front matter separators only (not underlines)\n        /^\\s*\\|.*\\|/gm.test(text), // Table syntax\n    comprehensiveCheck: (text) => {\n        const headers = (text.match(/^#{1,6} /gm) || []).length;\n        const bold = (text.match(/\\*\\*[^**]+\\*\\*/g) || []).length;\n        const italic = (text.match(/\\*[^ *]+\\*/g) || []).length;\n        const code = (text.match(/```[\\s\\S]*?```/g) || []).length;\n        const links = (text.match(/\\[.*\\]\\(.*\\)/g) || []).length;\n        // Be more specific about lists - exclude YAML-style lists with colons\n        const mdLists = (text.match(/^\\s*[-*+]\\s+[^:]+$/gm) || []).length;\n        const numberedLists = (text.match(/^\\s*\\d+\\.\\s+/gm) || []).length;\n        const lists = mdLists + numberedLists;\n        const tables = (text.match(/^\\s*\\|.*\\|/gm) || []).length;\n        const tableDelimiters = (text.match(/^\\s*\\|[-\\s:|]+\\|/gm) || []).length;\n        // Proper YAML front matter separators (not underlines)\n        const yamlSeparators = (text.match(/^---\\s*$|^---\\s*\\n/gm) || []).length;\n        // Tables: give higher score for clear table structures\n        const tableScore = tables > 2\n            ? 2\n            : tables > 1 || (tables > 0 && tableDelimiters > 0)\n                ? 1\n                : 0;\n        // More conservative detection - require multiple distinct Markdown features\n        const markdownScore = headers +\n            bold +\n            italic +\n            code +\n            links +\n            lists +\n            tableScore +\n            yamlSeparators;\n        // Check for decorative patterns that suggest plain text formatting\n        const decorativeLines = (text.match(/^\\s*[*\\-=_]{3,}\\s*$/gm) || []).length;\n        const isLikelyPlainTextFormatting = decorativeLines > 1; // Multiple decorative lines suggest plain text\n        // Require at least 2 different types of Markdown features for high confidence\n        const featureTypes = [\n            headers > 0,\n            bold > 0 && !isLikelyPlainTextFormatting, // Discount bold if it looks like decorative formatting\n            italic > 0,\n            code > 0,\n            links > 0,\n            lists > 0 && !isLikelyPlainTextFormatting, // Discount lists if it looks like plain text formatting\n            tableScore > 0,\n            yamlSeparators > 0,\n        ].filter(Boolean).length;\n        // Be very conservative: require strong indicators or multiple diverse features\n        return (code > 0 || // Code blocks are strong indicators\n            links > 1 || // Multiple links suggest Markdown\n            headers > 2 || // Multiple headers suggest Markdown\n            (featureTypes >= 3 && !isLikelyPlainTextFormatting) || // Multiple features without plain text formatting\n            (tables > 0 && tableDelimiters > 0) // Proper table structure\n        );\n    },\n    quickConfidence: 0.6,\n    compConfidence: 0.9,\n    mimeType: \"text/markdown\",\n    extension: \"md\",\n    reasons: [\n        \"Markdown syntax like headers, bold, code, links, or lists detected\",\n        \"Multiple Markdown elements confirmed\",\n    ],\n};\n","export const htmlCheck = {\n    quickCheck: (text) => {\n        const trimmed = text.trim();\n        // Exclude XML first (XML is strictly defined)\n        if (trimmed.startsWith(\"<?xml\")) {\n            return false;\n        }\n        // Handle truncated content (head + tail sample)\n        const isTruncatedSample = text.includes(\"[CONTENT_TRUNCATED]\");\n        let actualStart = trimmed;\n        let actualEnd = trimmed;\n        if (isTruncatedSample) {\n            const parts = text.split(\"[CONTENT_TRUNCATED]\");\n            if (parts.length >= 2) {\n                actualStart = parts[0].trim();\n                actualEnd = parts[parts.length - 1].trim();\n            }\n        }\n        // Strong indicator: starts and ends with tags (but not XML)\n        const startsWithTag = /^<[a-z!][^>]*>/i.test(actualStart);\n        const endsWithTag = /<\\/[a-z][^>]*>$|<[^>]*\\/>$|>$/i.test(actualEnd);\n        if (startsWithTag && endsWithTag) {\n            return true; // Very strong HTML indicator if not XML\n        }\n        // DOCTYPE is always HTML\n        if (trimmed.toLowerCase().startsWith(\"<!doctype html>\")) {\n            return true;\n        }\n        // Look for HTML tags in the first portion\n        return /<([a-z][a-z0-9]*)/i.test(text.slice(0, 1000));\n    },\n    comprehensiveCheck: (text) => {\n        const trimmed = text.trim();\n        // Exclude XML first (XML is strictly defined)\n        if (trimmed.startsWith(\"<?xml\") || /xmlns[:=]/i.test(text)) {\n            return false;\n        }\n        // Handle truncated content (head + tail sample)\n        const isTruncatedSample = text.includes(\"[CONTENT_TRUNCATED]\");\n        let actualStart = trimmed;\n        let actualEnd = trimmed;\n        if (isTruncatedSample) {\n            const parts = text.split(\"[CONTENT_TRUNCATED]\");\n            if (parts.length >= 2) {\n                actualStart = parts[0].trim();\n                actualEnd = parts[parts.length - 1].trim();\n            }\n        }\n        // Very strong indicator: content is fully enclosed in tags (and not XML)\n        const startsWithTag = /^<[a-z!][^>]*>/i.test(actualStart);\n        const endsWithTag = /<\\/[a-z][^>]*>$|<[^>]*\\/>$|>$/i.test(actualEnd);\n        if (startsWithTag && endsWithTag) {\n            // For tag-enclosed content, still check tag balance to avoid false positives\n            const openTags = (text.match(/<([a-z][a-z0-9]*)/gi) || []).length;\n            const closeTags = (text.match(/<\\/([a-z][a-z0-9]*)/gi) || []).length;\n            const tagBalance = Math.abs(openTags - closeTags) <= Math.max(1, openTags * 0.5);\n            // Only return true for well-formed tag-enclosed content\n            if (tagBalance && openTags > 0) {\n                return true; // Very high confidence for well-formed tag-enclosed content\n            }\n        }\n        const openTags = (text.match(/<([a-z][a-z0-9]*)/gi) || []).length;\n        const closeTags = (text.match(/<\\/([a-z][a-z0-9]*)/gi) || []).length;\n        // HTML-specific: common attributes or self-closing tags\n        const hasHtmlAttrs = /class=|id=|href=|src=|style=|alt=|title=/i.test(text) ||\n            /<[^>]*\\/>/i.test(text);\n        const hasDoctype = text.trim().toLowerCase().startsWith(\"<!doctype html>\");\n        // Strong HTML indicators take precedence over Markdown patterns\n        if (hasDoctype || (openTags > 3 && hasHtmlAttrs)) {\n            // Check if tags are reasonably balanced (allowing for self-closing tags)\n            const tagBalance = Math.abs(openTags - closeTags) <= Math.max(1, openTags * 0.5);\n            return tagBalance && openTags > 0;\n        }\n        // Exclude Markdown: if it has strong MD markers, let MD win (even with HTML)\n        const mdMarkers = [\n            /^#{1,6} /gm, // headers\n            /\\*\\*[^*]+\\*\\*/g, // bold\n            /\\[.*\\]\\(.*\\)/g, // links\n            /```/g, // code blocks\n            /^\\s*[-*+]\\s+/gm, // lists\n        ];\n        const mdMatches = mdMarkers.reduce((count, pattern) => count + (text.match(pattern) || []).length, 0);\n        // If content has strong Markdown indicators, let Markdown win\n        if (mdMatches > 2) {\n            return false; // Let markdown handler take precedence\n        }\n        // For HTML detection: need at least 1 tag\n        if (openTags === 0) {\n            return false;\n        }\n        // For snippets: need either HTML-specific attributes OR multiple balanced tags\n        if (!hasHtmlAttrs && openTags < 2) {\n            return false;\n        }\n        // Check if tags are reasonably balanced (allowing for self-closing tags)\n        const tagBalance = Math.abs(openTags - closeTags) <= Math.max(1, openTags * 0.5);\n        return tagBalance;\n    },\n    quickConfidence: 0.7,\n    compConfidence: 0.95,\n    mimeType: \"text/html\",\n    extension: \"html\",\n    reasons: [\n        \"HTML doctype or opening tag detected in snippet\",\n        \"Balanced tags with HTML-specific attributes or self-closing elements (distinguishes from XML)\",\n    ],\n};\n","export const jsonCheck = {\n    quickCheck: (text) => {\n        const trimmed = text.trim();\n        // Check for JSON array, object, string, number, boolean, or null\n        return (/^\\s*[\\[\\{]/.test(trimmed) || // array or object\n            /^\\s*\"/.test(trimmed) || // string\n            /^\\s*-?\\d+(\\.\\d+)?([eE][+-]?\\d+)?\\s*$/.test(trimmed) || // number\n            /^\\s*(true|false|null)\\s*$/.test(trimmed) // boolean or null\n        );\n    },\n    comprehensiveCheck: (text) => {\n        try {\n            JSON.parse(text);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    },\n    quickConfidence: 0.5,\n    compConfidence: 1.0,\n    mimeType: \"application/json\",\n    extension: \"json\",\n    reasons: [\n        \"Content starts with JSON array or object bracket\",\n        \"Full content parses as valid JSON\",\n    ],\n};\n","export const xmlCheck = {\n    quickCheck: (text) => {\n        const trimmed = text.trim();\n        if (trimmed.startsWith(\"<?xml\")) {\n            return true;\n        }\n        // Exclude common HTML tags\n        if (/<(html|body|div|p|span|img|br|meta|head|title)/i.test(trimmed))\n            return false;\n        // Require XML-specific: namespace or attribute patterns\n        return (/<([a-zA-Z_:][a-zA-Z0-9_.:-]*)(\\s+[^>]*xmlns[^>]*)?>/.test(text.slice(0, 100)) ||\n            /<[^>]+xmlns:/.test(text.slice(0, 100)) ||\n            (/<[^>]*\\/>/.test(text.slice(0, 100)) && /<[^>]*xmlns/.test(text)));\n    },\n    comprehensiveCheck: (text) => {\n        const openTags = (text.match(/<([a-zA-Z_:][a-zA-Z0-9_.:-]*)/g) || [])\n            .length;\n        const closeTags = (text.match(/<\\/([a-zA-Z_:][a-zA-Z0-9_.:-]*)/g) || [])\n            .length;\n        const hasRoot = /<([a-zA-Z_:][a-zA-Z0-9_.:-]*)([^>]*)>/.test(text);\n        // Exclude HTML\n        if (/<(html|body|div|p)/i.test(text)) {\n            return false;\n        }\n        return openTags > 1 && Math.abs(openTags - closeTags) < 2 && hasRoot;\n    },\n    quickConfidence: 0.6,\n    compConfidence: 0.9,\n    mimeType: \"application/xml\",\n    extension: \"xml\",\n    reasons: [\n        \"XML declaration or namespace-tagged element detected (excluding HTML)\",\n        \"Well-formed XML structure with root element (non-HTML)\",\n    ],\n};\n","export const csvCheck = {\n    quickCheck: (text) => {\n        const trimmed = text.trim();\n        // Exclusion patterns: HTML/XML content\n        if (trimmed.toLowerCase().startsWith(\"<!doctype\") ||\n            trimmed.startsWith(\"<?xml\") ||\n            /<[a-z][a-z0-9]*[^>]*>/i.test(trimmed.slice(0, 200))) {\n            return false;\n        }\n        // Exclusion pattern: YAML front matter\n        if (trimmed.startsWith(\"---\")) {\n            return false;\n        }\n        return text.includes(\",\");\n    },\n    comprehensiveCheck: (text) => {\n        const trimmed = text.trim();\n        // Additional exclusions for comprehensive check\n        if (trimmed.toLowerCase().startsWith(\"<!doctype\") ||\n            trimmed.startsWith(\"<?xml\") ||\n            /<[a-z][a-z0-9]*[^>]*>/i.test(trimmed.slice(0, 500)) ||\n            trimmed.startsWith(\"---\")) {\n            return false;\n        }\n        const lines = text.split(\"\\n\").filter((l) => l.trim());\n        if (lines.length < 2) {\n            return false;\n        }\n        const commaLines = lines.filter((l) => l.includes(\",\")).length;\n        return commaLines / lines.length > 0.8;\n    },\n    quickConfidence: 0.4,\n    compConfidence: 0.8,\n    mimeType: \"text/csv\",\n    extension: \"csv\",\n    reasons: [\n        \"Comma delimiter present\",\n        \"Majority of lines contain commas indicating CSV structure\",\n    ],\n};\n","export const yamlCheck = {\n    quickCheck: (text) => {\n        const trimmed = text.trim();\n        // Exclusion patterns: HTML/XML content\n        if (trimmed.toLowerCase().startsWith(\"<!doctype\") ||\n            trimmed.startsWith(\"<?xml\") ||\n            /<[a-z][a-z0-9]*[^>]*>/i.test(trimmed.slice(0, 200))) {\n            return false;\n        }\n        // Check for YAML front matter\n        if (trimmed.startsWith(\"---\")) {\n            return true;\n        }\n        // Exclude JavaScript object literals - they start with { and have unquoted keys\n        if (trimmed.startsWith(\"{\") && /[a-zA-Z_$][a-zA-Z0-9_$]*\\s*:/.test(text)) {\n            return false;\n        }\n        const colonCount = (text.match(/:\\s/g) || []).length;\n        const listCount = (text.match(/^\\s*-\\s/gm) || []).length;\n        return colonCount > 0 || listCount > 0;\n    },\n    comprehensiveCheck: (text) => {\n        // Exclusion patterns: HTML/XML content\n        if (text.trim().toLowerCase().startsWith(\"<!doctype\") ||\n            text.trim().startsWith(\"<?xml\") ||\n            /<[a-z][a-z0-9]*[^>]*>/i.test(text.slice(0, 500))) {\n            return false;\n        }\n        // Exclude content with HTML style blocks (CSS properties)\n        if (/<style[^>]*>[\\s\\S]*<\\/style>/i.test(text)) {\n            return false;\n        }\n        // Exclude JavaScript object literals (unquoted keys in braces)\n        if (text.trim().startsWith(\"{\") &&\n            /[a-zA-Z_$][a-zA-Z0-9_$]*\\s*:/.test(text)) {\n            return false;\n        }\n        // Check for decorative patterns that suggest plain text formatting\n        const decorativeLines = (text.match(/^\\s*[*\\-=_]{3,}\\s*$/gm) || []).length;\n        const isLikelyPlainTextFormatting = decorativeLines > 2; // Multiple decorative lines suggest plain text\n        // If it looks like plain text formatting, be much more strict about YAML detection\n        if (isLikelyPlainTextFormatting) {\n            // Only consider it YAML if it has clear YAML front matter or very structured data patterns\n            if (text.trim().startsWith(\"---\") && text.includes(\"---\", 3)) {\n                return true; // Clear YAML front matter\n            }\n            // For plain text with decorative formatting, require very clear YAML structure\n            const structuredData = (text.match(/^\\s*[a-z_][a-z0-9_]*:\\s*$/gm) || [])\n                .length; // Keys on their own lines\n            const nestedStructure = /^\\s{2,}[a-z_][a-z0-9_]*:\\s/.test(text); // Indented nested structure\n            return structuredData > 3 && nestedStructure; // Require clear structure\n        }\n        // Check for YAML front matter format\n        if (text.trim().startsWith(\"---\") && text.includes(\"---\", 3)) {\n            const frontMatterEnd = text.indexOf(\"---\", 3);\n            const frontMatter = text.slice(3, frontMatterEnd);\n            const keyValue = (frontMatter.match(/^\\s*[^:]+:\\s+/gm) || []).length;\n            if (keyValue > 0) {\n                return true;\n            }\n        }\n        const keyValue = (text.match(/^\\s*[^:]+:\\s+/gm) || []).length;\n        const listItems = (text.match(/^\\s*-\\s+/gm) || []).length;\n        const indented = /:\\s*\\n\\s+[^\\s]/.test(text);\n        return keyValue > 1 || (listItems > 1 && indented);\n    },\n    quickConfidence: 0.5,\n    compConfidence: 0.85,\n    mimeType: \"text/yaml\",\n    extension: \"yaml\",\n    reasons: [\n        \"YAML key-value pair or list item detected\",\n        \"Multiple structured YAML elements with indentation confirmed\",\n    ],\n};\n","export const txtCheck = {\n    quickCheck: () => true,\n    comprehensiveCheck: () => true,\n    quickConfidence: 0.1,\n    compConfidence: 0.1,\n    mimeType: \"text/plain\",\n    extension: \"txt\",\n    reasons: [\n        \"Default plain text fallback - no specific format markers detected\",\n    ],\n};\n","export const texCheck = {\n    quickCheck: (text) => text.includes(\"\\\\documentclass\") ||\n        /\\\\([a-zA-Z]+){/.test(text) ||\n        /\\\\begin\\{/.test(text),\n    comprehensiveCheck: (text) => {\n        const commands = (text.match(/\\\\([a-zA-Z]+)/g) || []).length;\n        const environments = (text.match(/\\\\begin\\{[^}]+\\}/g) || []).length +\n            (text.match(/\\\\end\\{[^}]+\\}/g) || []).length;\n        // For minimal documents: require \\documentclass and document environment\n        const hasDocumentclass = /\\\\documentclass/.test(text);\n        const hasDocumentEnv = /\\\\begin\\{document\\}/.test(text) && /\\\\end\\{document\\}/.test(text);\n        if (hasDocumentclass && hasDocumentEnv) {\n            return true; // Minimal LaTeX document\n        }\n        // For other LaTeX content: require multiple commands and environments\n        return commands > 3 && environments > 0;\n    },\n    quickConfidence: 0.7,\n    compConfidence: 0.95,\n    mimeType: \"text/x-tex\",\n    extension: \"tex\",\n    reasons: [\n        \"LaTeX command or environment detected\",\n        \"Multiple LaTeX commands and environments found\",\n    ],\n};\n","import { mdCheck } from \"./formats/md.js\";\nimport { htmlCheck } from \"./formats/html.js\";\nimport { jsonCheck } from \"./formats/json.js\";\nimport { xmlCheck } from \"./formats/xml.js\";\nimport { csvCheck } from \"./formats/csv.js\";\nimport { yamlCheck } from \"./formats/yaml.js\";\nimport { txtCheck } from \"./formats/txt.js\";\nimport { texCheck } from \"./formats/tex.js\";\n/**\n * File format utilities\n */\n// Formats to check, where there are definition files in `./formats/{format}.ts`\nconst textFormatChecks = [\n    \"md\",\n    \"html\",\n    \"json\",\n    \"xml\",\n    \"csv\",\n    \"yaml\",\n    \"txt\",\n    \"tex\",\n];\n/**\n * Detect the file format from the given text.\n * @param {string} [content] - Text format for analysis - this or filePath is required\n * @param {string} [filePath] - Get content from filesystem path - this or content is required\n * @param {string[]} [formats] - Optional list of formats to check against (defaults to all known text formats)\n * @returns {Promise<FormatResponse>} Object of detected format properties\n */\nexport const detectFormatFromText = async ({ content, filePath, formats = [], }) => {\n    // `content` or `filePath` is required\n    if (content === undefined && filePath === undefined) {\n        throw new Error(\"Either `content` or `filePath` is required\");\n    }\n    // Set defaults after validation\n    content = content || \"\";\n    filePath = filePath || \"\";\n    if (filePath && !content) {\n        const isNode = typeof process !== \"undefined\" && !!process.versions?.node;\n        if (!isNode) {\n            throw new Error(\"Reading from filePath is only supported in Node.js environments.\");\n        }\n        const fs = await import(\"fs/promises\");\n        content = await fs.readFile(filePath, \"utf8\");\n    }\n    const checkFormats = formats.length ? formats : textFormatChecks;\n    // Create better samples for detection - head + tail for container detection\n    const sampleSize = 2000;\n    let sample;\n    if (content.length <= sampleSize * 2) {\n        // If content is small enough, use the full content\n        sample = content;\n    }\n    else {\n        // For larger content, combine head and tail samples\n        const head = content.slice(0, sampleSize);\n        const tail = content.slice(-sampleSize);\n        sample = head + \"\\n...[CONTENT_TRUNCATED]...\\n\" + tail;\n    }\n    // Static format checks\n    const formatChecks = {\n        md: mdCheck,\n        html: htmlCheck,\n        json: jsonCheck,\n        xml: xmlCheck,\n        csv: csvCheck,\n        yaml: yamlCheck,\n        txt: txtCheck,\n        tex: texCheck,\n    };\n    let bestMatch = {\n        format: \"txt\",\n        mimeType: \"text/plain\",\n        extension: \"txt\",\n        confidence: 0.1,\n        reasons: [\n            \"Defaulted to plain text format - low confidence level for all other formats\",\n        ],\n    };\n    for (const format of checkFormats) {\n        const check = formatChecks[format];\n        if (!check)\n            continue;\n        const quickMatch = check.quickCheck(sample);\n        if (!quickMatch)\n            continue;\n        let thisConfidence;\n        let thisReasons;\n        if (check.comprehensiveCheck) {\n            const compText = format === \"json\" ? content : sample;\n            const compMatch = check.comprehensiveCheck(compText);\n            if (!compMatch)\n                continue; // Skip if comprehensive fails - avoid false positives\n            thisConfidence = check.compConfidence;\n            thisReasons = check.reasons;\n        }\n        else {\n            // Fallback for formats without comp (none currently, but for future)\n            thisConfidence = check.quickConfidence;\n            thisReasons = check.reasons;\n        }\n        if (thisConfidence > (bestMatch.confidence || 0)) {\n            bestMatch = {\n                format,\n                mimeType: check.mimeType,\n                extension: check.extension,\n                confidence: thisConfidence,\n                reasons: thisReasons,\n            };\n        }\n    }\n    return bestMatch;\n};\n"],"file":"index-CXXj2l9q.js"}