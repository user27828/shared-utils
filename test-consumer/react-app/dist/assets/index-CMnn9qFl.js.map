{"version":3,"mappings":"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","names":["mdCheck","text","headers","bold","italic","code","links","mdLists","numberedLists","lists","tables","tableDelimiters","tableScore","htmlCheck","openTags","closeTags","count","pattern","hasHtmlAttrs","jsonCheck","trimmed","xmlCheck","hasRoot","csvCheck","lines","l","yamlCheck","colonCount","listCount","frontMatterEnd","keyValue","listItems","indented","txtCheck","texCheck","commands","environments","hasDocumentclass","hasDocumentEnv","textFormatChecks","detectFormatFromText","content","filePath","formats","checkFormats","sample","formatChecks","bestMatch","format","check","thisConfidence","thisReasons","compText"],"ignoreList":[],"sources":["../../../../dist/utils/src/detectFormat/formats/md.js","../../../../dist/utils/src/detectFormat/formats/html.js","../../../../dist/utils/src/detectFormat/formats/json.js","../../../../dist/utils/src/detectFormat/formats/xml.js","../../../../dist/utils/src/detectFormat/formats/csv.js","../../../../dist/utils/src/detectFormat/formats/yaml.js","../../../../dist/utils/src/detectFormat/formats/txt.js","../../../../dist/utils/src/detectFormat/formats/tex.js","../../../../dist/utils/src/detectFormat/index.js"],"sourcesContent":["export const mdCheck = {\n    quickCheck: (text) => /^#{1,6} /gm.test(text) ||\n        /\\*\\*/.test(text) ||\n        /```/.test(text) ||\n        /\\[.*\\]\\(/.test(text) ||\n        /^\\s*[-*+]\\s/gm.test(text) ||\n        /---\\n/.test(text) ||\n        /^\\s*\\|.*\\|/gm.test(text), // Table syntax\n    comprehensiveCheck: (text) => {\n        const headers = (text.match(/^#{1,6} /gm) || []).length;\n        const bold = (text.match(/\\*\\*[^**]+\\*\\*/g) || []).length;\n        const italic = (text.match(/\\*[^ *]+\\*/g) || []).length;\n        const code = (text.match(/```[\\s\\S]*?```/g) || []).length;\n        const links = (text.match(/\\[.*\\]\\(.*\\)/g) || []).length;\n        // Be more specific about lists - exclude YAML-style lists with colons\n        const mdLists = (text.match(/^\\s*[-*+]\\s+[^:]+$/gm) || []).length;\n        const numberedLists = (text.match(/^\\s*\\d+\\.\\s+/gm) || []).length;\n        const lists = mdLists + numberedLists;\n        const tables = (text.match(/^\\s*\\|.*\\|/gm) || []).length;\n        const tableDelimiters = (text.match(/^\\s*\\|[-\\s:|]+\\|/gm) || []).length;\n        // Tables: give higher score for clear table structures\n        const tableScore = tables > 2\n            ? 2\n            : tables > 1 || (tables > 0 && tableDelimiters > 0)\n                ? 1\n                : 0;\n        return headers + bold + italic + code + links + lists + tableScore > 1;\n    },\n    quickConfidence: 0.6,\n    compConfidence: 0.9,\n    mimeType: \"text/markdown\",\n    extension: \"md\",\n    reasons: [\n        \"Markdown syntax like headers, bold, code, links, or lists detected\",\n        \"Multiple Markdown elements confirmed\",\n    ],\n};\n","export const htmlCheck = {\n    quickCheck: (text) => {\n        const trimmed = text.trim();\n        return (trimmed.startsWith(\"<!DOCTYPE html>\") ||\n            /<([a-z][a-z0-9]*)/i.test(text.slice(0, 1000)));\n    },\n    comprehensiveCheck: (text) => {\n        const openTags = (text.match(/<([a-z][a-z0-9]*)/gi) || []).length;\n        const closeTags = (text.match(/<\\/([a-z][a-z0-9]*)/gi) || []).length;\n        // Exclude XML: reject if has XML declaration or XML namespaces\n        if (text.trim().startsWith(\"<?xml\") || /xmlns[:=]/i.test(text)) {\n            return false;\n        }\n        // Exclude Markdown: if it has multiple MD markers, let MD win\n        const mdMarkers = [\n            /^#{1,6} /gm, // headers\n            /\\*\\*[^*]+\\*\\*/g, // bold\n            /\\[.*\\]\\(.*\\)/g, // links\n            /```/g, // code blocks\n            /^\\s*[-*+]\\s+/gm, // lists\n        ];\n        const mdMatches = mdMarkers.reduce((count, pattern) => count + (text.match(pattern) || []).length, 0);\n        if (mdMatches > 1) {\n            return false; // Let markdown handler take precedence\n        }\n        // HTML-specific: common attributes or self-closing tags\n        const hasHtmlAttrs = /class=|id=|href=|src=|style=|alt=|title=/i.test(text) ||\n            /<[^>]*\\/>/i.test(text);\n        // For HTML detection: need at least 1 tag\n        if (openTags === 0) {\n            return false;\n        }\n        // For snippets: need either HTML-specific attributes OR multiple balanced tags\n        if (!hasHtmlAttrs && openTags < 2) {\n            return false;\n        }\n        // Check if tags are reasonably balanced (allowing for self-closing tags)\n        const tagBalance = Math.abs(openTags - closeTags) <= Math.max(1, openTags * 0.5);\n        return tagBalance;\n    },\n    quickConfidence: 0.7,\n    compConfidence: 0.95,\n    mimeType: \"text/html\",\n    extension: \"html\",\n    reasons: [\n        \"HTML doctype or opening tag detected in snippet\",\n        \"Balanced tags with HTML-specific attributes or self-closing elements (distinguishes from XML)\",\n    ],\n};\n","export const jsonCheck = {\n    quickCheck: (text) => {\n        const trimmed = text.trim();\n        // Check for JSON array, object, string, number, boolean, or null\n        return (/^\\s*[\\[\\{]/.test(trimmed) || // array or object\n            /^\\s*\"/.test(trimmed) || // string\n            /^\\s*-?\\d+(\\.\\d+)?([eE][+-]?\\d+)?\\s*$/.test(trimmed) || // number\n            /^\\s*(true|false|null)\\s*$/.test(trimmed) // boolean or null\n        );\n    },\n    comprehensiveCheck: (text) => {\n        try {\n            JSON.parse(text);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    },\n    quickConfidence: 0.5,\n    compConfidence: 1.0,\n    mimeType: \"application/json\",\n    extension: \"json\",\n    reasons: [\n        \"Content starts with JSON array or object bracket\",\n        \"Full content parses as valid JSON\",\n    ],\n};\n","export const xmlCheck = {\n    quickCheck: (text) => {\n        const trimmed = text.trim();\n        if (trimmed.startsWith(\"<?xml\")) {\n            return true;\n        }\n        // Exclude common HTML tags\n        if (/<(html|body|div|p|span|img|br|meta|head|title)/i.test(trimmed))\n            return false;\n        // Require XML-specific: namespace or attribute patterns\n        return (/<([a-zA-Z_:][a-zA-Z0-9_.:-]*)(\\s+[^>]*xmlns[^>]*)?>/.test(text.slice(0, 100)) ||\n            /<[^>]+xmlns:/.test(text.slice(0, 100)) ||\n            (/<[^>]*\\/>/.test(text.slice(0, 100)) && /<[^>]*xmlns/.test(text)));\n    },\n    comprehensiveCheck: (text) => {\n        const openTags = (text.match(/<([a-zA-Z_:][a-zA-Z0-9_.:-]*)/g) || [])\n            .length;\n        const closeTags = (text.match(/<\\/([a-zA-Z_:][a-zA-Z0-9_.:-]*)/g) || [])\n            .length;\n        const hasRoot = /<([a-zA-Z_:][a-zA-Z0-9_.:-]*)([^>]*)>/.test(text);\n        // Exclude HTML\n        if (/<(html|body|div|p)/i.test(text)) {\n            return false;\n        }\n        return openTags > 1 && Math.abs(openTags - closeTags) < 2 && hasRoot;\n    },\n    quickConfidence: 0.6,\n    compConfidence: 0.9,\n    mimeType: \"application/xml\",\n    extension: \"xml\",\n    reasons: [\n        \"XML declaration or namespace-tagged element detected (excluding HTML)\",\n        \"Well-formed XML structure with root element (non-HTML)\",\n    ],\n};\n","export const csvCheck = {\n    quickCheck: (text) => text.includes(\",\"),\n    comprehensiveCheck: (text) => {\n        const lines = text.split(\"\\n\").filter((l) => l.trim());\n        if (lines.length < 2) {\n            return false;\n        }\n        const commaLines = lines.filter((l) => l.includes(\",\")).length;\n        return commaLines / lines.length > 0.8;\n    },\n    quickConfidence: 0.4,\n    compConfidence: 0.8,\n    mimeType: \"text/csv\",\n    extension: \"csv\",\n    reasons: [\n        \"Comma delimiter present\",\n        \"Majority of lines contain commas indicating CSV structure\",\n    ],\n};\n","export const yamlCheck = {\n    quickCheck: (text) => {\n        const trimmed = text.trim();\n        // Check for YAML front matter\n        if (trimmed.startsWith(\"---\")) {\n            return true;\n        }\n        // Exclude JavaScript object literals - they start with { and have unquoted keys\n        if (trimmed.startsWith(\"{\") && /[a-zA-Z_$][a-zA-Z0-9_$]*\\s*:/.test(text))\n            return false;\n        const colonCount = (text.match(/:\\s/g) || []).length;\n        const listCount = (text.match(/^\\s*-\\s/gm) || []).length;\n        return colonCount > 0 || listCount > 0;\n    },\n    comprehensiveCheck: (text) => {\n        // Exclude JavaScript object literals (unquoted keys in braces)\n        if (text.trim().startsWith(\"{\") &&\n            /[a-zA-Z_$][a-zA-Z0-9_$]*\\s*:/.test(text))\n            return false;\n        // Check for YAML front matter format\n        if (text.trim().startsWith(\"---\") && text.includes(\"---\", 3)) {\n            const frontMatterEnd = text.indexOf(\"---\", 3);\n            const frontMatter = text.slice(3, frontMatterEnd);\n            const keyValue = (frontMatter.match(/^\\s*[^:]+:\\s+/gm) || []).length;\n            if (keyValue > 0) {\n                return true;\n            }\n        }\n        const keyValue = (text.match(/^\\s*[^:]+:\\s+/gm) || []).length;\n        const listItems = (text.match(/^\\s*-\\s+/gm) || []).length;\n        const indented = /:\\s*\\n\\s+[^\\s]/.test(text);\n        return keyValue > 1 || (listItems > 1 && indented);\n    },\n    quickConfidence: 0.5,\n    compConfidence: 0.85,\n    mimeType: \"text/yaml\",\n    extension: \"yaml\",\n    reasons: [\n        \"YAML key-value pair or list item detected\",\n        \"Multiple structured YAML elements with indentation confirmed\",\n    ],\n};\n","export const txtCheck = {\n    quickCheck: () => true,\n    comprehensiveCheck: () => true,\n    quickConfidence: 0.1,\n    compConfidence: 0.1,\n    mimeType: \"text/plain\",\n    extension: \"txt\",\n    reasons: [\n        \"Default plain text fallback - no specific format markers detected\",\n    ],\n};\n","export const texCheck = {\n    quickCheck: (text) => text.includes(\"\\\\documentclass\") ||\n        /\\\\([a-zA-Z]+){/.test(text) ||\n        /\\\\begin\\{/.test(text),\n    comprehensiveCheck: (text) => {\n        const commands = (text.match(/\\\\([a-zA-Z]+)/g) || []).length;\n        const environments = (text.match(/\\\\begin\\{[^}]+\\}/g) || []).length +\n            (text.match(/\\\\end\\{[^}]+\\}/g) || []).length;\n        // For minimal documents: require \\documentclass and document environment\n        const hasDocumentclass = /\\\\documentclass/.test(text);\n        const hasDocumentEnv = /\\\\begin\\{document\\}/.test(text) && /\\\\end\\{document\\}/.test(text);\n        if (hasDocumentclass && hasDocumentEnv) {\n            return true; // Minimal LaTeX document\n        }\n        // For other LaTeX content: require multiple commands and environments\n        return commands > 3 && environments > 0;\n    },\n    quickConfidence: 0.7,\n    compConfidence: 0.95,\n    mimeType: \"text/x-tex\",\n    extension: \"tex\",\n    reasons: [\n        \"LaTeX command or environment detected\",\n        \"Multiple LaTeX commands and environments found\",\n    ],\n};\n","import { mdCheck } from \"./formats/md\";\nimport { htmlCheck } from \"./formats/html\";\nimport { jsonCheck } from \"./formats/json\";\nimport { xmlCheck } from \"./formats/xml\";\nimport { csvCheck } from \"./formats/csv\";\nimport { yamlCheck } from \"./formats/yaml\";\nimport { txtCheck } from \"./formats/txt\";\nimport { texCheck } from \"./formats/tex\";\n/**\n * File format utilities\n */\n// Formats to check, where there are definition files in `./formats/{format}.ts`\nconst textFormatChecks = [\n    \"md\",\n    \"html\",\n    \"json\",\n    \"xml\",\n    \"csv\",\n    \"yaml\",\n    \"txt\",\n    \"tex\",\n];\n/**\n * Detect the file format from the given text.\n * @param {string} [content] - Text format for analysis - this or filePath is required\n * @param {string} [filePath] - Get content from filesystem path - this or content is required\n * @param {string[]} [formats] - Optional list of formats to check against (defaults to all known text formats)\n * @returns {Promise<FormatResponse>} Object of detected format properties\n */\nexport const detectFormatFromText = async ({ content, filePath, formats = [], }) => {\n    // `content` or `filePath` is required\n    if (content === undefined && filePath === undefined) {\n        throw new Error(\"Either `content` or `filePath` is required\");\n    }\n    // Set defaults after validation\n    content = content || \"\";\n    filePath = filePath || \"\";\n    if (filePath && !content) {\n        const isNode = typeof process !== \"undefined\" && !!process.versions?.node;\n        if (!isNode) {\n            throw new Error(\"Reading from filePath is only supported in Node.js environments.\");\n        }\n        const fs = await import(\"fs/promises\");\n        content = await fs.readFile(filePath, \"utf8\");\n    }\n    const checkFormats = formats.length ? formats : textFormatChecks;\n    const sample = content.slice(0, 2000);\n    // Static format checks\n    const formatChecks = {\n        md: mdCheck,\n        html: htmlCheck,\n        json: jsonCheck,\n        xml: xmlCheck,\n        csv: csvCheck,\n        yaml: yamlCheck,\n        txt: txtCheck,\n        tex: texCheck,\n    };\n    let bestMatch = {\n        format: \"txt\",\n        mimeType: \"text/plain\",\n        extension: \"txt\",\n        confidence: 0.1,\n        reasons: [\n            \"Defaulted to plain text format - low confidence level for all other formats\",\n        ],\n    };\n    for (const format of checkFormats) {\n        const check = formatChecks[format];\n        if (!check)\n            continue;\n        const quickMatch = check.quickCheck(sample);\n        if (!quickMatch)\n            continue;\n        let thisConfidence;\n        let thisReasons;\n        if (check.comprehensiveCheck) {\n            const compText = format === \"json\" ? content : sample;\n            const compMatch = check.comprehensiveCheck(compText);\n            if (!compMatch)\n                continue; // Skip if comprehensive fails - avoid false positives\n            thisConfidence = check.compConfidence;\n            thisReasons = check.reasons;\n        }\n        else {\n            // Fallback for formats without comp (none currently, but for future)\n            thisConfidence = check.quickConfidence;\n            thisReasons = check.reasons;\n        }\n        if (thisConfidence > (bestMatch.confidence || 0)) {\n            bestMatch = {\n                format,\n                mimeType: check.mimeType,\n                extension: check.extension,\n                confidence: thisConfidence,\n                reasons: thisReasons,\n            };\n        }\n    }\n    return bestMatch;\n};\n"],"file":"assets/index-CMnn9qFl.js"}