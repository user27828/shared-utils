{"version":3,"file":"imageVariantWorker-CKZ81EDv.js","sources":["../../../dist/client/src/fm/workers/imageVariantWorker.js"],"sourcesContent":["/**\n * Image Variant Web Worker — shared-utils/client/fm/workers\n *\n * Runs image resizing off the main thread using OffscreenCanvas.\n * Receives a Blob + target widths, returns an array of resized Blobs.\n *\n * Ported from db-supabase/client/fm/workers/imageVariantWorker.ts.\n */\nimport { MAX_CANVAS_DIMENSION, } from \"../utils/imageVariants.js\";\nconst chooseTargetWidths = (input) => {\n    const out = (input.widths || [])\n        .map((w) => Math.floor(w))\n        .filter((w) => Number.isFinite(w) && w > 0 && w <= input.sourceWidth);\n    if (out.length === 0) {\n        return [Math.max(1, Math.floor(input.sourceWidth))];\n    }\n    return Array.from(new Set(out)).sort((a, b) => a - b);\n};\nconst tryEncode = async (input) => {\n    const q = Math.min(1, Math.max(0.1, input.quality));\n    if (input.preferWebp) {\n        try {\n            const b = await input.canvas.convertToBlob({\n                type: \"image/webp\",\n                quality: q,\n            });\n            if (b && b.size > 0) {\n                return { blob: b, mimeType: \"image/webp\" };\n            }\n        }\n        catch {\n            // ignore — fall through to JPEG\n        }\n    }\n    const jpeg = await input.canvas.convertToBlob({\n        type: \"image/jpeg\",\n        quality: q,\n    });\n    return { blob: jpeg, mimeType: \"image/jpeg\" };\n};\nself.onmessage = (ev) => {\n    (async () => {\n        const req = ev.data;\n        const maxCanvasDim = Math.max(1, Math.min(8192, Math.floor(req.maxCanvasDimension || MAX_CANVAS_DIMENSION)));\n        const preferWebp = req.preferWebp !== false;\n        const quality = typeof req.quality === \"number\" ? req.quality : 0.82;\n        if (typeof self.createImageBitmap !== \"function\") {\n            self.postMessage({\n                ok: false,\n                error: \"createImageBitmap not supported\",\n            });\n            return;\n        }\n        const bitmap = await self.createImageBitmap(req.blob, { imageOrientation: \"from-image\" });\n        const sourceWidth = bitmap.width;\n        const sourceHeight = bitmap.height;\n        // Constrain to canvas limits (use local max if overridden).\n        const constrained = (() => {\n            const maxDim = Math.max(sourceWidth, sourceHeight);\n            if (maxDim <= maxCanvasDim) {\n                return {\n                    width: sourceWidth,\n                    height: sourceHeight,\n                    wasConstrained: false,\n                };\n            }\n            const scale = maxCanvasDim / maxDim;\n            return {\n                width: Math.floor(sourceWidth * scale),\n                height: Math.floor(sourceHeight * scale),\n                wasConstrained: true,\n            };\n        })();\n        const targetWidths = chooseTargetWidths({\n            widths: req.widths,\n            sourceWidth: constrained.width,\n        });\n        // If constrained, redraw to a safe size first.\n        let baseBitmap = bitmap;\n        if (constrained.wasConstrained) {\n            const oc = new OffscreenCanvas(constrained.width, constrained.height);\n            const ctx = oc.getContext(\"2d\");\n            if (!ctx) {\n                throw new Error(\"Unable to get canvas context\");\n            }\n            ctx.drawImage(bitmap, 0, 0, constrained.width, constrained.height);\n            baseBitmap = oc.transferToImageBitmap();\n            bitmap.close();\n        }\n        const variants = [];\n        for (const w of targetWidths) {\n            const h = Math.max(1, Math.round((baseBitmap.height * w) / baseBitmap.width));\n            if (Math.max(w, h) > maxCanvasDim) {\n                continue;\n            }\n            const oc = new OffscreenCanvas(w, h);\n            const ctx = oc.getContext(\"2d\");\n            if (!ctx) {\n                continue;\n            }\n            ctx.drawImage(baseBitmap, 0, 0, w, h);\n            const encoded = await tryEncode({ canvas: oc, preferWebp, quality });\n            variants.push({\n                targetWidth: w,\n                targetHeight: h,\n                mimeType: encoded.mimeType,\n                blob: encoded.blob,\n            });\n        }\n        baseBitmap.close();\n        const result = {\n            sourceWidth,\n            sourceHeight,\n            constrainedWidth: constrained.width,\n            constrainedHeight: constrained.height,\n            wasConstrained: constrained.wasConstrained,\n            variants,\n        };\n        self.postMessage({ ok: true, result });\n    })().catch((err) => {\n        self.postMessage({\n            ok: false,\n            error: err?.message || \"Worker failed\",\n        });\n    });\n};\n"],"names":["chooseTargetWidths","input","out","w","a","b","tryEncode","q","ev","req","maxCanvasDim","preferWebp","quality","bitmap","sourceWidth","sourceHeight","constrained","maxDim","scale","targetWidths","baseBitmap","oc","ctx","variants","h","encoded","result","err"],"mappings":"yBASA,MAAMA,EAAsBC,GAAU,CAClC,MAAMC,GAAOD,EAAM,QAAU,CAAA,GACxB,IAAKE,GAAM,KAAK,MAAMA,CAAC,CAAC,EACxB,OAAQA,GAAM,OAAO,SAASA,CAAC,GAAKA,EAAI,GAAKA,GAAKF,EAAM,WAAW,EACxE,OAAIC,EAAI,SAAW,EACR,CAAC,KAAK,IAAI,EAAG,KAAK,MAAMD,EAAM,WAAW,CAAC,CAAC,EAE/C,MAAM,KAAK,IAAI,IAAIC,CAAG,CAAC,EAAE,KAAK,CAACE,EAAGC,IAAMD,EAAIC,CAAC,CACxD,EACMC,EAAY,MAAOL,GAAU,CAC/B,MAAMM,EAAI,KAAK,IAAI,EAAG,KAAK,IAAI,GAAKN,EAAM,OAAO,CAAC,EAClD,GAAIA,EAAM,WACN,GAAI,CACA,MAAMI,EAAI,MAAMJ,EAAM,OAAO,cAAc,CACvC,KAAM,aACN,QAASM,CACzB,CAAa,EACD,GAAIF,GAAKA,EAAE,KAAO,EACd,MAAO,CAAE,KAAMA,EAAG,SAAU,YAAY,CAEhD,MACM,CAEN,CAMJ,MAAO,CAAE,KAJI,MAAMJ,EAAM,OAAO,cAAc,CAC1C,KAAM,aACN,QAASM,CACjB,CAAK,EACoB,SAAU,YAAY,CAC/C,EACA,KAAK,UAAaC,GAAO,EACpB,SAAY,CACT,MAAMC,EAAMD,EAAG,KACTE,EAAe,KAAK,IAAI,EAAG,KAAK,IAAI,KAAM,KAAK,MAAMD,EAAI,oBAAsB,IAAoB,CAAC,CAAC,EACrGE,EAAaF,EAAI,aAAe,GAChCG,EAAU,OAAOH,EAAI,SAAY,SAAWA,EAAI,QAAU,IAChE,GAAI,OAAO,KAAK,mBAAsB,WAAY,CAC9C,KAAK,YAAY,CACb,GAAI,GACJ,MAAO,iCACvB,CAAa,EACD,MACJ,CACA,MAAMI,EAAS,MAAM,KAAK,kBAAkBJ,EAAI,KAAM,CAAE,iBAAkB,aAAc,EAClFK,EAAcD,EAAO,MACrBE,EAAeF,EAAO,OAEtBG,GAAe,IAAM,CACvB,MAAMC,EAAS,KAAK,IAAIH,EAAaC,CAAY,EACjD,GAAIE,GAAUP,EACV,MAAO,CACH,MAAOI,EACP,OAAQC,EACR,eAAgB,EACpC,EAEY,MAAMG,EAAQR,EAAeO,EAC7B,MAAO,CACH,MAAO,KAAK,MAAMH,EAAcI,CAAK,EACrC,OAAQ,KAAK,MAAMH,EAAeG,CAAK,EACvC,eAAgB,EAChC,CACQ,GAAC,EACKC,EAAenB,EAAmB,CACpC,OAAQS,EAAI,OACZ,YAAaO,EAAY,KACrC,CAAS,EAED,IAAII,EAAaP,EACjB,GAAIG,EAAY,eAAgB,CAC5B,MAAMK,EAAK,IAAI,gBAAgBL,EAAY,MAAOA,EAAY,MAAM,EAC9DM,EAAMD,EAAG,WAAW,IAAI,EAC9B,GAAI,CAACC,EACD,MAAM,IAAI,MAAM,8BAA8B,EAElDA,EAAI,UAAUT,EAAQ,EAAG,EAAGG,EAAY,MAAOA,EAAY,MAAM,EACjEI,EAAaC,EAAG,sBAAqB,EACrCR,EAAO,MAAK,CAChB,CACA,MAAMU,EAAW,CAAA,EACjB,UAAWpB,KAAKgB,EAAc,CAC1B,MAAMK,EAAI,KAAK,IAAI,EAAG,KAAK,MAAOJ,EAAW,OAASjB,EAAKiB,EAAW,KAAK,CAAC,EAC5E,GAAI,KAAK,IAAIjB,EAAGqB,CAAC,EAAId,EACjB,SAEJ,MAAMW,EAAK,IAAI,gBAAgBlB,EAAGqB,CAAC,EAC7BF,EAAMD,EAAG,WAAW,IAAI,EAC9B,GAAI,CAACC,EACD,SAEJA,EAAI,UAAUF,EAAY,EAAG,EAAGjB,EAAGqB,CAAC,EACpC,MAAMC,EAAU,MAAMnB,EAAU,CAAE,OAAQe,EAAI,WAAAV,EAAY,QAAAC,EAAS,EACnEW,EAAS,KAAK,CACV,YAAapB,EACb,aAAcqB,EACd,SAAUC,EAAQ,SAClB,KAAMA,EAAQ,IAC9B,CAAa,CACL,CACAL,EAAW,MAAK,EAChB,MAAMM,EAAS,CACX,YAAAZ,EACA,aAAAC,EACA,iBAAkBC,EAAY,MAC9B,kBAAmBA,EAAY,OAC/B,eAAgBA,EAAY,eAC5B,SAAAO,CACZ,EACQ,KAAK,YAAY,CAAE,GAAI,GAAM,OAAAG,CAAM,CAAE,CACzC,GAAC,EAAI,MAAOC,GAAQ,CAChB,KAAK,YAAY,CACb,GAAI,GACJ,MAAOA,GAAK,SAAW,eACnC,CAAS,CACL,CAAC,CACL"}